grammar goL.tasks.TaskDSL with org.eclipse.xtext.common.Terminals

generate taskDSL "http://www.tasks.goL/TaskDSL"

Model:
    'Experiment' name=ID ':'
    functions += FunctionDef*
    grid = Grid
    rules = Rules;

// -----------------------------------------------------------------------------
// GRID DEFINITION
// -----------------------------------------------------------------------------
Grid:
    'Grid' ':'
    'Size' 
    	sizeX=INT 
    	'x' 
    	sizeY=INT
    'InitialState' ':'
	stateOption = InitialStateOption;
	
InitialStateOption:
    (
        {StaticState} 'Static' cells += LiveCell* // Option 1: Static list of LiveCells
    ) | (
        {RandomState} 'Random' percentage=INT '%' // Option 2: Random fill percentage
    ) | (
    	{ProgramState} 'Program' program=Expr
    );

LiveCell:
    '(' x=INT ',' y=INT ')';

// -----------------------------------------------------------------------------
// RULES DEFINITION
// -----------------------------------------------------------------------------
Rules:
    'Rules' ':'
    birthRules 		+= BirthRule+
    survivalRules 	+= SurvivalRule+
    deathRules 		+= DeathRule+;

// NOTE: Rule definitions are explicit to avoid parser confusion.

// A dead cell becomes alive (birth)
BirthRule:
    'Birth' 	'Neighbors' (operator=Operator count=INT);

SurvivalRule:
    'Survival' 	'Neighbors' (operator=Operator count=INT);

DeathRule:
    'Death' 	'Neighbors' (operator=Operator count=INT);




// Defines the operators for comparison: <, =, >
enum Operator:
    LESS_THAN = '<' | EQUAL = '=' | GREATER_THAN = '>';


// -----------------------------------------------------------------------------
// EXPRESSIONS
// References:
// https://medium.com/typefox/parsing-expressions-with-xtext-86fb5855d420
// https://eclipse.dev/Xtext/documentation/307_special_languages.html
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// EXPRESSIONS
// -----------------------------------------------------------------------------
FunctionDef:
    'Function' name=ID '(' params+=ID (',' params+=ID)* ')' ':'
          '{' statements+=Statement+ '}'
;


Statement:
      VarDecl
    | Assignment
    | IfStatement
    | WhileLoop
    | ReturnStmt
;

VarDecl:
    'let' name=ID '=' expr=Expr
;

Assignment:
    name=ID '=' expr=Expr
;

IfStatement:
    'if' '(' condition=Expr ')' ':'
        '{' thenStatements+=Statement+ '}'
;


WhileLoop:
    'while' '(' condition=Expr ')' ':'
        '{' statements+=Statement+ '}'
;

ReturnStmt:
    'return' expr=Expr
;

Expr returns Expr:
    OrExpr
;

OrExpr returns Expr:
    AndExpr ({Or.left=current} '||' right=AndExpr)*
;

AndExpr returns Expr:
    EqualityExpr ({And.left=current} '&&' right=EqualityExpr)*
;

EqualityExpr returns Expr:
    RelationalExpr (({Eq.left=current} '==' right=RelationalExpr)
                  | ({Neq.left=current} '!=' right=RelationalExpr))*
;

RelationalExpr returns Expr:
    AddExpr (({Lt.left=current} '<' right=AddExpr)
           | ({Lte.left=current} '<=' right=AddExpr)
           | ({Gt.left=current} '>' right=AddExpr)
           | ({Gte.left=current} '>=' right=AddExpr))*
;

AddExpr returns Expr:
    MulExpr (({Add.left=current} '+' right=MulExpr)
           | ({Sub.left=current} '-' right=MulExpr))*
;


MulExpr returns Expr:
    PrimaryExpr (({Mul.left=current} '*' right=PrimaryExpr)
               | ({Div.left=current} '/' right=PrimaryExpr)
               | ({Mod.left=current} '%' right=PrimaryExpr))*
;


PrimaryExpr returns Expr:
      NumberLiteral
    | VariableRef
    | FunctionCall
    | ParenExpr
;

FunctionCall returns Expr:
    {FunctionCall} funcName=ID '(' (args+=Expr (',' args+=Expr)*)? ')'
;

ParenExpr returns Expr:
    {ParenExpr} '(' expr=Expr ')'
;

NumberLiteral returns Expr:
    {NumberLiteral} value=INT
;

VariableRef returns Expr:
    {VariableRef} varName=ID
;

