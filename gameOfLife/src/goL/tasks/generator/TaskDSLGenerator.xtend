/*
 * generated by Xtext 2.28.0
 */
package goL.tasks.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import goL.tasks.taskDSL.Model
import goL.tasks.taskDSL.Grid
import goL.tasks.taskDSL.LiveCell
import goL.tasks.taskDSL.Operator
import goL.tasks.taskDSL.BirthRule
import goL.tasks.taskDSL.SurvivalRule
import goL.tasks.taskDSL.DeathRule
import goL.tasks.taskDSL.InitialStateOption
import goL.tasks.taskDSL.RandomState
import goL.tasks.taskDSL.StaticState 

import goL.tasks.taskDSL.Expr
import goL.tasks.taskDSL.NumberLiteral
import goL.tasks.taskDSL.FloatLiteral

import goL.tasks.taskDSL.VariableRef
import goL.tasks.taskDSL.Add
import goL.tasks.taskDSL.Sub
import goL.tasks.taskDSL.Mul
import goL.tasks.taskDSL.Div
import goL.tasks.taskDSL.FunctionCall
import goL.tasks.taskDSL.ParenExpr
import goL.tasks.taskDSL.FunctionState
import goL.tasks.taskDSL.PatternState
import goL.tasks.taskDSL.PatternDefinition
import goL.tasks.taskDSL.CirclePattern
import goL.tasks.taskDSL.RectanglePattern
import goL.tasks.taskDSL.TrianglePattern
import goL.tasks.taskDSL.PatternModifier
import goL.tasks.taskDSL.Tub
import goL.tasks.taskDSL.Boat
import goL.tasks.taskDSL.Block
import goL.tasks.taskDSL.BeeHive
import goL.tasks.taskDSL.Loaf
import goL.tasks.taskDSL.Blinker
import goL.tasks.taskDSL.Pentadecathlon
import goL.tasks.taskDSL.Pulsar
import goL.tasks.taskDSL.Beacon
import goL.tasks.taskDSL.Toad
import goL.tasks.taskDSL.Glider
import goL.tasks.taskDSL.SpaceShip
import goL.tasks.taskDSL.GosperGun
import goL.tasks.taskDSL.CustomPattern
import goL.tasks.taskDSL.CustPatternState
import goL.tasks.taskDSL.StaticEraseState

/**
 * Generates the RulesOfLife.java file based on the Game of Life DSL model.
 */
class TaskDSLGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		// 1. Get the root Model element
		val model = resource.allContents.filter(Model).head
		
		// 2. Delegate the generation to the dispatch method
		// The generated Java file will be placed in 'src-gen/RulesOfLife.java'
		// It is important that this path reflects the package structure!
		fsa.generateFile("GameOfLife/RulesOfLife.java", model.toJavaCode)
	}
	def String exprToJava(Expr expr) {
	    if (expr instanceof NumberLiteral) {
	        return (expr as NumberLiteral).value.toString
	    } else if (expr instanceof FloatLiteral) {
	        return (expr as FloatLiteral).value.toString
	    } else if (expr instanceof VariableRef) {
	        return (expr as VariableRef).varName
	    } else if (expr instanceof Add) {
	        return "(" + exprToJava((expr as Add).left) + " + " + exprToJava((expr as Add).right) + ")"
	    } else if (expr instanceof Sub) {
	        return "(" + exprToJava((expr as Sub).left) + " - " + exprToJava((expr as Sub).right) + ")"
	    } else if (expr instanceof Mul) {
	        return "(" + exprToJava((expr as Mul).left) + " * " + exprToJava((expr as Mul).right) + ")"
	    } else if (expr instanceof Div) {
	        return "(" + exprToJava((expr as Div).left) + " / " + exprToJava((expr as Div).right) + ")"
	    } else if (expr instanceof FunctionCall) {
	        val fc = expr as FunctionCall
	        val argStr = exprToJava(fc.argument)
	        switch fc.funcName {
	            case "sin"	: return "Math.sin(" 		+ argStr + ")"
	            case "cos"	: return "Math.cos(" 		+ argStr + ")"
	            case "tan"	: return "Math.tan(" 		+ argStr + ")"
	            case "sqrt"	: return "Math.sqrt(" 		+ argStr + ")"
	            case "abs"	: return "Math.abs(" 		+ argStr + ")"
	            default		: return fc.funcName + "(" 	+ argStr + ")"
	        }
	    } else if (expr instanceof ParenExpr) {
	        return "(" + exprToJava((expr as ParenExpr).expr) + ")"
	    } else {
	        throw new IllegalStateException("Unhandled expr type: " + typeof(Expr))
	    }
	}



	
	/**
	 * Main dispatch method that generates the complete Java class.
	 */
	def toJavaCode(Model model) '''
		// This file was automatically generated from the DSL instance: «model.name»
		package GameOfLife; // <-- ADDED PACKAGE DECLARATION
		
		import java.awt.Point;
		import java.util.ArrayList;

		public class RulesOfLife {
		
		    // --- GRID CONFIGURATION (Generated from DSL) ---
		    public static final int GRID_WIDTH = «model.grid.sizeX»;
		    public static final int GRID_HEIGHT = «model.grid.sizeY»;
		
		    // Initial state setup (true = alive)
		    public static boolean[][] INITIAL_GRID = new boolean[GRID_WIDTH][GRID_HEIGHT];
			«toCustomPatternDefinitions(model)» 
		    // Static block to initialize the grid with live cells (defined in the DSL's Grid section)
		    static {
		        «model.grid.toInitialCellSetup»
		    }
		
		
		    // --- EVOLUTION RULES (Generated from DSL) ---
		
		    /**
		     * Determines the next state of a cell based on its current state and live neighbors.
		     * This method contains the custom rules defined in the DSL.
		     * * @param currentState true if the cell is currently alive, false otherwise.
		     * @param liveNeighbors the count of live neighbors (0 to 8).
		     * @return the state of the cell in the next generation.
		     */
		    public static boolean determineNextState(boolean currentState, int liveNeighbors) {
		        
		        // If the cell is currently ALIVE (Survival and Death Rules apply)
		        if (currentState) {
		            // ----------------------------------------------------
		            // SURVIVAL RULES: If any survival rule matches, the cell lives.
		            // ----------------------------------------------------
		            «model.rules.survivalRules.toConditionBlock("Survival")»
		            
		            // ----------------------------------------------------
		            // DEATH RULES: If no survival rule matched, we check for explicit death conditions.
		            // ----------------------------------------------------
		            «model.rules.deathRules.toConditionBlock("Death")»

		            // If a live cell meets neither an explicit survival nor death condition,
		            // it defaults to death (as is standard in most GoL variations).
		            return false;
		            
		        } 
		        
		        // If the cell is currently DEAD (Birth Rules apply)
		        else {
		            // ----------------------------------------------------
		            // BIRTH RULES: If any birth rule matches, the cell is born.
		            // ----------------------------------------------------
		            «model.rules.birthRules.toConditionBlock("Birth")»
		            
		            return false; // Default: stay dead
		        }
		    }
		    
		    // --- GAME LOOP IMPLEMENTATION (Required by GameOfLife.java) ---
		    
		    /**
		     * Computes the list of cells that will be alive in the next generation
		     * based on the current board state and the DSL-defined rules.
		     * * @param gameBoard The current padded board state (true=alive, false=dead).
		     * @param survivingCells The list to which the coordinates of the next generation's live cells will be added.
		     */
		    public static void computeSurvivors(boolean[][] gameBoard, ArrayList<Point> survivingCells) {
		    	// Note: gameBoard is padded by 1 on all sides for neighbor counting (i=1 to length-2)
		        for (int i=1; i<gameBoard.length-1; i++) {
		            for (int j=1; j<gameBoard[0].length-1; j++) {
		                int surrounding = 0;
		                
		                // Neighbor Counting Logic (8 directions)
		                if (gameBoard[i-1][j-1]) { surrounding++; }
		                if (gameBoard[i-1][j])   { surrounding++; }
		                if (gameBoard[i-1][j+1]) { surrounding++; }
		                if (gameBoard[i][j-1])   { surrounding++; }
		                if (gameBoard[i][j+1])   { surrounding++; }
		                if (gameBoard[i+1][j-1]) { surrounding++; }
		                if (gameBoard[i+1][j])   { surrounding++; }
		                if (gameBoard[i+1][j+1]) { surrounding++; }
		                
		                // Determine next state using the DSL-generated rules
		                // The cell at (i, j) corresponds to the unpadded coordinate (i-1, j-1)
		                if (determineNextState(gameBoard[i][j], surrounding)) {
		                    survivingCells.add(new Point(i-1, j-1));
		                }
		            }
		        }
		    }
    		«toApplyPatternMethod»
		}
	'''
	
	
	/**
	 * Generates the Java code for initializing the live cells in the static block.
	 */
	def toInitialCellSetup(Grid grid) '''
	  «FOR option : grid.options»
		«IF option instanceof RandomState»
			«val randomState = option as RandomState»
			«val percentage = randomState.percentage»
			
			// Use Java's Random to fill the board with the specified percentage (percentage»%)
			java.util.Random random = new java.util.Random();
			int totalCells = GRID_WIDTH * GRID_HEIGHT;
			int cellsToFill = (int) Math.round(totalCells * («percentage» / 100.0));
			int filledCount = 0;

			// Loop until the desired number of cells is filled
			while (filledCount < cellsToFill) {
				int x = random.nextInt(GRID_WIDTH);
				int y = random.nextInt(GRID_HEIGHT);
				
				// Only set if the cell was previously dead
				if (!INITIAL_GRID[x][y]) {
					INITIAL_GRID[x][y] = true;
					filledCount++;
				}
			}
		«ELSEIF option instanceof StaticEraseState»
				// Static Fill
				«val staticEraseState = option as StaticEraseState»
				«FOR cell : staticEraseState.cells»
					INITIAL_GRID[«cell.x»][«cell.y»] = false;
				«ENDFOR»
		«ELSEIF option instanceof FunctionState»
				«val funcState = option as FunctionState»
				
				// Initialize grid based on a function of two variables f(c, r), plotting a line/curve.
				// A cell is alive if f(c,r) is close to zero.
				// TOLERANCE defines the thickness of the line.

				final double TOLERANCE = «IF funcState.tolerance !== null »«funcState.tolerance»«ELSE»1.0«ENDIF»;
				
				
				for (int c = 0; c < GRID_WIDTH; c++) {
				  for (int r = 0; r < GRID_HEIGHT; r++) {
					double result = «exprToJava(funcState.function)»;
					// Check if the function result is close to zero (i.e., on the curve f(c,r) = 0)
					if (Math.abs(result) < TOLERANCE) {
						INITIAL_GRID[c][r] = true;
					}
				  }
				}
		«ELSEIF option instanceof PatternState»
				«val patternState = option as PatternState»
				// Pattern Definition
				«patternState.pattern.toPatternSetup»
		«ELSEIF option instanceof CustPatternState»
                «val custPatternState = option as CustPatternState»
                // Place a defined NamedPattern at an offset
                «custPatternState.toNamedPatternPlacement»
		«ELSE»
			// Static Fill
			«val staticState = option as StaticState»
			«FOR cell : staticState.cells»
			INITIAL_GRID[«cell.x»][«cell.y»] = true;
			«ENDFOR»
			
		«ENDIF»
	  «ENDFOR»
	'''
	
	/**
	 * Generates the Java 'if' conditions for the evolution rules.
	 * This helper method takes a list of rules (Birth, Survival, or Death) and generates
	 * the corresponding 'if' blocks, using explicit casting to resolve type dispatch issues.
	 */
	def toConditionBlock(Iterable<?> rules, String ruleType) '''
		«val conditions = switch ruleType {
			case "Birth": rules.filter(BirthRule).map[r | r.toConditionString].join(" || ")
			case "Survival": rules.filter(SurvivalRule).map[r | r.toConditionString].join(" || ")
			case "Death": rules.filter(DeathRule).map[r | r.toConditionString].join(" || ")
			default: ""
		}»
		
		// Generated «ruleType» Condition: «conditions»
		if («conditions») {
			return «IF ruleType == "Birth" || ruleType == "Survival"»true«ELSE»false«ENDIF»;
		}
	'''
	
	/**
	 * Dispatches to the specific rule type to generate the single 'liveNeighbors' condition.
	 */
	def toConditionString(BirthRule rule) {
		'liveNeighbors ' + rule.operator.toSymbol + ' ' + rule.count
	}
	
	def toConditionString(SurvivalRule rule) {
		'liveNeighbors ' + rule.operator.toSymbol + ' ' + rule.count
	}
	
	def toConditionString(DeathRule rule) {
		'liveNeighbors ' + rule.operator.toSymbol + ' ' + rule.count
	}

	/**
	 * Maps the DSL's Operator Enum to the Java Symbol.
	 */
	def toSymbol(Operator operator) {
		switch operator {
			case Operator.LESS_THAN: '<'
			case Operator.EQUAL: '=='
			case Operator.GREATER_THAN: '>'
		}
	}

	def toPatternSetup(PatternDefinition pattern) '''
        «IF pattern instanceof CirclePattern» «pattern.toCircleSetup»
        «ELSEIF pattern instanceof RectanglePattern» «pattern.toRectangleSetup»
        «ELSEIF pattern instanceof TrianglePattern» «pattern.toTriangleSetup»
        
        «ELSEIF pattern instanceof Block» «pattern.toBlockSetup»
        «ELSEIF pattern instanceof BeeHive» «pattern.toBeeHiveSetup»
        «ELSEIF pattern instanceof Loaf» «pattern.toLoafSetup»
        «ELSEIF pattern instanceof Boat» «pattern.toBoatSetup»
        «ELSEIF pattern instanceof Tub» «pattern.toTubSetup»
        
        «ELSEIF pattern instanceof Blinker» «pattern.toBlinkerSetup»
        «ELSEIF pattern instanceof Toad» «pattern.toToadSetup»
        «ELSEIF pattern instanceof Beacon» «pattern.toBeaconSetup»
        «ELSEIF pattern instanceof Pulsar» «pattern.toPulsarSetup»
        «ELSEIF pattern instanceof Pentadecathlon» «pattern.toPentadecathlonSetup»
 
	    «ELSEIF pattern instanceof Glider» «pattern.toGliderSetup»
	    «ELSEIF pattern instanceof SpaceShip» «pattern.toSpaceShipSetup»
	    «ELSEIF pattern instanceof GosperGun» «pattern.toGosperGunSetup»
 
        «ENDIF»
	'''
	
	/**
	 * Generates code for the Circle Pattern.
	 */
	def toCircleSetup(CirclePattern circle) '''
        // Circle Pattern: center(«circle.centerX», «circle.centerY»), radius «circle.radius»
        {
            final int cx = «circle.centerX»;
            final int cy = «circle.centerY»;
            final int r = «circle.radius»;
            final int rSquared = r * r;
			final boolean shouldSet = «IF circle.modifier == PatternModifier.ERASE»false«ELSE»true«ENDIF»; // true for fill/default, false for erase
            final boolean fillMode = «IF circle.modifier == PatternModifier.FILL || circle.modifier == PatternModifier.ERASE»true«ELSE»false«ENDIF»; // true for fill/erase, false for line drawing
            final double LINE_TOLERANCE_SQUARED = «IF circle.tolerance !== null »«circle.tolerance»«ELSE»10.0«ENDIF»;

            for (int c = 0; c < GRID_WIDTH; c++) {
                for (int r_cell = 0; r_cell < GRID_HEIGHT; r_cell++) {
                    int distSquared = (c - cx) * (c - cx) + (r_cell - cy) * (r_cell - cy);

                    boolean match = false;
                    if (fillMode) {
                        // Fill or Erase mode: check if inside or on the boundary
                        match = distSquared <= rSquared;
                    } else {
                        // Line mode (default): check if near the boundary
                        match = Math.abs(distSquared - rSquared) < LINE_TOLERANCE_SQUARED;
                    }
                    
                    if (match) {
                        INITIAL_GRID[c][r_cell] = shouldSet;
                    }
                }
            }
        }
	'''

	/**
	 * Generates code for the Rectangle Pattern.
	 * It calculates the bounding box and iterates over it.
	 * NOTE: Assumes p1 and p3 are diagonally opposite for filling logic, 
	 * but uses all four for robustness. It uses the min/max of all X/Y coordinates to define the bounding box.
	 */
	def toRectangleSetup(RectanglePattern rect) '''
        // Rectangle Pattern: p1(«rect.p1.x», «rect.p1.y»), p2(...), etc.
        {
            final int minX = Math.min(Math.min(«rect.p1.x», «rect.p2.x»), Math.min(«rect.p3.x», «rect.p4.x»));
            final int maxX = Math.max(Math.max(«rect.p1.x», «rect.p2.x»), Math.max(«rect.p3.x», «rect.p4.x»));
            final int minY = Math.min(Math.min(«rect.p1.y», «rect.p2.y»), Math.min(«rect.p3.y», «rect.p4.y»));
            final int maxY = Math.max(Math.max(«rect.p1.y», «rect.p2.y»), Math.max(«rect.p3.y», «rect.p4.y»));

            final boolean shouldSet = «IF rect.modifier == PatternModifier.ERASE»false«ELSE»true«ENDIF»;
            final boolean isRectFill = «IF rect.modifier == PatternModifier.FILL»true«ELSE»false«ENDIF»;
            final boolean isRectErase = «IF rect.modifier == PatternModifier.ERASE»true«ELSE»false«ENDIF»;
                   
            final boolean fillMode = «IF rect.modifier == PatternModifier.FILL || rect.modifier == PatternModifier.ERASE»true«ELSE»false«ENDIF»;

            for (int c = minX; c <= maxX; c++) {
                for (int r_cell = minY; r_cell <= maxY; r_cell++) {
                    if (c >= 0 && c < GRID_WIDTH && r_cell >= 0 && r_cell < GRID_HEIGHT) {
                        
                        boolean isBoundary = (c == minX || c == maxX || r_cell == minY || r_cell == maxY);
                        
                        if (fillMode) {
                            // Fill or Erase mode: set all cells in the bounding box
                            INITIAL_GRID[c][r_cell] = shouldSet;
                        } else if (isBoundary) {
                            // Line mode (default): set only the boundary cells
                            INITIAL_GRID[c][r_cell] = shouldSet;
                        }
                    }
                }
            }
        }
	'''
	
	/**
	 * Generates code for the Triangle Pattern using the Barycentric coordinate method for filling.
	 */
	def toTriangleSetup(TrianglePattern tri) '''
        // Triangle Pattern: p1(«tri.p1.x», «tri.p1.y»), p2(«tri.p2.x», «tri.p2.y»), p3(«tri.p3.x», «tri.p3.y»)
        {
            final double x1 = «tri.p1.x», y1 = «tri.p1.y»;
            final double x2 = «tri.p2.x», y2 = «tri.p2.y»;
            final double x3 = «tri.p3.x», y3 = «tri.p3.y»;
            
            final boolean shouldSet = «IF tri.modifier == PatternModifier.ERASE»false«ELSE»true«ENDIF»;
            final boolean fillMode = «IF tri.modifier == PatternModifier.FILL || tri.modifier == PatternModifier.ERASE»true«ELSE»false«ENDIF»;
			
            // Precalculate denominator for Barycentric coordinates (Area * 2)
            final double area2 = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);
            final double ABS_AREA_2 = Math.abs(area2);
            final double EPSILON = «IF tri.tolerance !== null »«tri.tolerance»«ELSE»0.01«ENDIF»;; // Tolerance for floating point comparisons

            // Calculate bounding box for performance optimization
            final int minX = (int) Math.floor(Math.min(Math.min(x1, x2), x3));
            final int maxX = (int) Math.ceil(Math.max(Math.max(x1, x2), x3));
            final int minY = (int) Math.floor(Math.min(Math.min(y1, y2), y3));
            final int maxY = (int) Math.ceil(Math.max(Math.max(y1, y2), y3));

            for (int c = Math.max(0, minX); c < Math.min(GRID_WIDTH, maxX + 1); c++) {
                for (int r_cell = Math.max(0, minY); r_cell < Math.min(GRID_HEIGHT, maxY + 1); r_cell++) {
                    
                    // Barycentric Coordinate Calculation
                    // w1 = ((x2 - x) * (y3 - y) - (x3 - x) * (y2 - y)) / area2
                    final double w1 = ((x2 - c) * (y3 - r_cell) - (x3 - c) * (y2 - r_cell)) / area2;
                    // w2 = ((x3 - x) * (y1 - y) - (x1 - x) * (y3 - y)) / area2
                    final double w2 = ((x3 - c) * (y1 - r_cell) - (x1 - c) * (y3 - r_cell)) / area2;
                    // w3 = 1 - w1 - w2
                    final double w3 = 1.0 - w1 - w2;

                    // A point is inside the triangle if all weights are > 0.0
                    boolean isInside = w1 >= -EPSILON && w2 >= -EPSILON && w3 >= -EPSILON;

                    // Check if the point is close to the boundary (for line drawing)
                    boolean isBoundary = (Math.abs(w1) < EPSILON || Math.abs(w2) < EPSILON || Math.abs(w3) < EPSILON) && isInside;

                    if (fillMode) {
                        if (isInside) {
                            INITIAL_GRID[c][r_cell] = shouldSet;
                        }
                    } else if (isBoundary) {
                        INITIAL_GRID[c][r_cell] = shouldSet;
                    }
                }
            }
        }
	'''
	
	/**
	 * Generates code for the Block (2x2) pattern.
	 */
	def toBlockSetup(Block block) '''
		// Pattern Block at (block.anchor.x, block.anchor.y)
		{
			final int anchorX = «block.anchor.x»;
			final int anchorY = «block.anchor.y»;
			
			// Block (2x2)
			INITIAL_GRID[anchorX + 0][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 1][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 0][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 1][anchorY + 1] = true;
		}
	'''

	/**
	 * Generates code for the BeeHive (4x3) pattern.
	 */
	def toBeeHiveSetup(BeeHive beehive) '''
		// Pattern BeeHive at (beehive.anchor.x, beehive.anchor.y)
		{
			final int anchorX = «beehive.anchor.x»;
			final int anchorY = «beehive.anchor.y»;

			// BeeHive (4x3)
			INITIAL_GRID[anchorX + 1][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 2][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 0][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 3][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 1][anchorY + 2] = true;
			INITIAL_GRID[anchorX + 2][anchorY + 2] = true;
		}
	'''

	/**
	 * Generates code for the Loaf (4x4) pattern.
	 */
	def toLoafSetup(Loaf loaf) '''
		// Pattern Loaf at (loaf.anchor.x, loaf.anchor.y)
		{
			final int anchorX = «loaf.anchor.x»;
			final int anchorY = «loaf.anchor.y»;

			// Loaf (4x4)
			INITIAL_GRID[anchorX + 1][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 2][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 0][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 3][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 1][anchorY + 2] = true;
			INITIAL_GRID[anchorX + 3][anchorY + 2] = true;
			INITIAL_GRID[anchorX + 2][anchorY + 3] = true;
		}
	'''

	/**
	 * Generates code for the Boat (3x3) pattern.
	 */
	def toBoatSetup(Boat boat) '''
		// Pattern Boat at (boat.anchor.x, boat.anchor.y)
		{
			final int anchorX = «boat.anchor.x»;
			final int anchorY = «boat.anchor.y»;

			// Boat (3x3)
			INITIAL_GRID[anchorX + 0][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 1][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 0][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 2][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 1][anchorY + 2] = true;
		}
	'''

	/**
	 * Generates code for the Tub (3x3) pattern.
	 */
	def toTubSetup(Tub tub) '''
		// Pattern Tub at (tub.anchor.x, tub.anchor.y)
		{
			final int anchorX = «tub.anchor.x»;
			final int anchorY = «tub.anchor.y»;

			// Tub (3x3)
			INITIAL_GRID[anchorX + 1][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 0][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 2][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 1][anchorY + 2] = true;
		}
	'''
	
	/**
	 * Generates code for the Blinker (1x3) pattern.
	 */
	def toBlinkerSetup(Blinker blinker) '''
		// Pattern Blinker at (blinker.anchor.x, blinker.anchor.y)
		{
			final int anchorX = «blinker.anchor.x»;
			final int anchorY = «blinker.anchor.y»;

			// blinker (1x3)
			INITIAL_GRID[anchorX + 0][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 0][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 0][anchorY + 2] = true;
		}
	'''
	
	
/**
	 * Generates code for the Toad (4x2) pattern.
	 */
	def toToadSetup(Toad toad) '''
		// Pattern Toad at («toad.anchor.x», «toad.anchor.y»)
		{
			final int anchorX = «toad.anchor.x»;
			final int anchorY = «toad.anchor.y»;

			// Toad (4x2, 6 cells)
			// Row 0
			INITIAL_GRID[anchorX + 1][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 2][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 3][anchorY + 0] = true;
			// Row 1
			INITIAL_GRID[anchorX + 0][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 1][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 2][anchorY + 1] = true;
		}
	'''
	
	/**
	 * Generates code for the Beacon (4x4) pattern.
	 */
	def toBeaconSetup(Beacon beacon) '''
		// Pattern Beacon at («beacon.anchor.x», «beacon.anchor.y»)
		{
			final int anchorX = «beacon.anchor.x»;
			final int anchorY = «beacon.anchor.y»;

			// Beacon (4x4, 6 cells)
			// Top-Left 2x2 Block
			INITIAL_GRID[anchorX + 0][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 1][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 0][anchorY + 1] = true;
			// Bottom-Right 2x2 Block
			INITIAL_GRID[anchorX + 3][anchorY + 2] = true;
			INITIAL_GRID[anchorX + 2][anchorY + 3] = true;
			INITIAL_GRID[anchorX + 3][anchorY + 3] = true;
		}
	'''
	
/**
	 * Generates code for the Pulsar (13x13) pattern, Period 3.
	 * 
	 */
	def toPulsarSetup(Pulsar pulsar) '''
		// Pattern Pulsar at («pulsar.anchor.x», «pulsar.anchor.y») (13x13 Bounding Box)
		{
			final int anchorX = «pulsar.anchor.x»;
			final int anchorY = «pulsar.anchor.y»;

			INITIAL_GRID[anchorX + 2][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 3][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 4][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 8][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 9][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 10][anchorY + 0] = true;
			
			INITIAL_GRID[anchorX + 0][anchorY + 2] = true;
			INITIAL_GRID[anchorX + 5][anchorY + 2] = true;
			INITIAL_GRID[anchorX + 7][anchorY + 2] = true;
			INITIAL_GRID[anchorX + 12][anchorY + 2] = true;
			
			INITIAL_GRID[anchorX + 0][anchorY + 3] = true;
			INITIAL_GRID[anchorX + 5][anchorY + 3] = true;
			INITIAL_GRID[anchorX + 7][anchorY + 3] = true;
			INITIAL_GRID[anchorX + 12][anchorY + 3] = true;
			
			INITIAL_GRID[anchorX + 0][anchorY + 4] = true;
			INITIAL_GRID[anchorX + 5][anchorY + 4] = true;
			INITIAL_GRID[anchorX + 7][anchorY + 4] = true;
			INITIAL_GRID[anchorX + 12][anchorY + 4] = true;

			INITIAL_GRID[anchorX + 2][anchorY + 5] = true;
			INITIAL_GRID[anchorX + 3][anchorY + 5] = true;
			INITIAL_GRID[anchorX + 4][anchorY + 5] = true;
			INITIAL_GRID[anchorX + 8][anchorY + 5] = true;
			INITIAL_GRID[anchorX + 9][anchorY + 5] = true;
			INITIAL_GRID[anchorX + 10][anchorY + 5] = true;
						
			INITIAL_GRID[anchorX + 2][anchorY + 7] = true;
			INITIAL_GRID[anchorX + 3][anchorY + 7] = true;
			INITIAL_GRID[anchorX + 4][anchorY + 7] = true;
			INITIAL_GRID[anchorX + 8][anchorY + 7] = true;
			INITIAL_GRID[anchorX + 9][anchorY + 7] = true;
			INITIAL_GRID[anchorX + 10][anchorY + 7] = true;
			
			INITIAL_GRID[anchorX + 0][anchorY + 8] = true;
			INITIAL_GRID[anchorX + 5][anchorY + 8] = true;
			INITIAL_GRID[anchorX + 7][anchorY + 8] = true;
			INITIAL_GRID[anchorX + 12][anchorY + 8] = true;
			
			INITIAL_GRID[anchorX + 0][anchorY + 9] = true;
			INITIAL_GRID[anchorX + 5][anchorY + 9] = true;
			INITIAL_GRID[anchorX + 7][anchorY + 9] = true;
			INITIAL_GRID[anchorX + 12][anchorY + 9] = true;
			
			INITIAL_GRID[anchorX + 0][anchorY + 10] = true;
			INITIAL_GRID[anchorX + 5][anchorY + 10] = true;
			INITIAL_GRID[anchorX + 7][anchorY + 10] = true;
			INITIAL_GRID[anchorX + 12][anchorY + 10] = true;
			
			INITIAL_GRID[anchorX + 2][anchorY + 12] = true;
			INITIAL_GRID[anchorX + 3][anchorY + 12] = true;
			INITIAL_GRID[anchorX + 4][anchorY + 12] = true;
			INITIAL_GRID[anchorX + 8][anchorY + 12] = true;
			INITIAL_GRID[anchorX + 9][anchorY + 12] = true;
			INITIAL_GRID[anchorX + 10][anchorY + 12] = true;
		}
	'''
	
	/**
	 * Generates code for the Pentadecathlon (10x3) pattern, Period 15.
	 * 
	 */
	def toPentadecathlonSetup(Pentadecathlon pd) '''
		// Pattern Pentadecathlon at («pd.anchor.x», «pd.anchor.y») (10x3 Bounding Box)
		{
			final int anchorX = «pd.anchor.x»;
			final int anchorY = «pd.anchor.y»;

			// Blocks on top and bottom of the bar:
			INITIAL_GRID[anchorX + 3][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 4][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 5][anchorY + 0] = true;
			
			INITIAL_GRID[anchorX + 2][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 6][anchorY + 1] = true;
			
			INITIAL_GRID[anchorX + 1][anchorY + 2] = true;
			INITIAL_GRID[anchorX + 7][anchorY + 2] = true;

			INITIAL_GRID[anchorX + 0][anchorY + 4] = true;
			INITIAL_GRID[anchorX + 0][anchorY + 5] = true;
			INITIAL_GRID[anchorX + 8][anchorY + 4] = true;
			INITIAL_GRID[anchorX + 8][anchorY + 5] = true;
			
			INITIAL_GRID[anchorX + 1][anchorY + 7] = true;
			INITIAL_GRID[anchorX + 7][anchorY + 7] = true;
			
			INITIAL_GRID[anchorX + 2][anchorY + 8] = true;
			INITIAL_GRID[anchorX + 6][anchorY + 8] = true;
			
			INITIAL_GRID[anchorX + 3][anchorY + 9] = true;
			INITIAL_GRID[anchorX + 4][anchorY + 9] = true;
			INITIAL_GRID[anchorX + 5][anchorY + 9] = true;
		}
	'''
	
	/**
	 * Generates code for the Glider (3x3) pattern.
	 * Moves diagonally (1, 1) every 4 generations.
	 */
	def toGliderSetup(Glider glider) '''
		// Pattern Glider at («glider.anchor.x», «glider.anchor.y»)
		{
			final int anchorX = «glider.anchor.x»;
			final int anchorY = «glider.anchor.y»;

			INITIAL_GRID[anchorX + 2][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 0][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 2][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 1][anchorY + 2] = true;
			INITIAL_GRID[anchorX + 2][anchorY + 2] = true;
		}
	'''
	
	/**
	 * Generates code for the Lightweight, Mediumweight, and Heavyweight SpaceShips.
	 */
	def toSpaceShipSetup(SpaceShip spaceShip) '''
		// Pattern SpaceShip («spaceShip.size») at («spaceShip.anchor.x», «spaceShip.anchor.y»)
		{
			«IF spaceShip.size.toString == "light"»
				«toLightSpaceShipSetup(spaceShip.anchor.x, spaceShip.anchor.y)»
			«ELSEIF spaceShip.size.toString == "medium"»
				«toMediumSpaceShipSetup(spaceShip.anchor.x, spaceShip.anchor.y)»
			«ELSEIF spaceShip.size.toString == "large"»
				«toLargeSpaceShipSetup(spaceShip.anchor.x, spaceShip.anchor.y)»
			«ENDIF»
		}
	'''
	
	/**
	 * Private helper to set up the Lightweight SpaceShip (LWSS).
	 */
	private def toLightSpaceShipSetup(int anchorX, int anchorY) '''
		final int anchorX = «anchorX»;
		final int anchorY = «anchorY»;
							
		INITIAL_GRID[anchorX + 1][anchorY + 0] = true;
		INITIAL_GRID[anchorX + 2][anchorY + 0] = true;
		INITIAL_GRID[anchorX + 3][anchorY + 0] = true;
		INITIAL_GRID[anchorX + 4][anchorY + 0] = true;
		// Row 1
		INITIAL_GRID[anchorX + 0][anchorY + 1] = true;
		INITIAL_GRID[anchorX + 4][anchorY + 1] = true;
		// Row 2
		INITIAL_GRID[anchorX + 4][anchorY + 2] = true;
		// Row 3
		INITIAL_GRID[anchorX + 0][anchorY + 3] = true;
		INITIAL_GRID[anchorX + 3][anchorY + 3] = true;
	'''
	
	/**
	 * Private helper to set up the Mediumweight SpaceShip (MWSS).
	 */
	private def toMediumSpaceShipSetup(int anchorX, int anchorY) '''
		final int anchorX = «anchorX»;
		final int anchorY = «anchorY»;
		
		INITIAL_GRID[anchorX + 2][anchorY + 0] = true;
		
		INITIAL_GRID[anchorX + 0][anchorY + 1] = true;
		INITIAL_GRID[anchorX + 4][anchorY + 1] = true;
		
		INITIAL_GRID[anchorX + 5][anchorY + 2] = true;
		
		INITIAL_GRID[anchorX + 5][anchorY + 3] = true;
		INITIAL_GRID[anchorX + 0][anchorY + 3] = true;
		
		INITIAL_GRID[anchorX + 1][anchorY + 4] = true;
		INITIAL_GRID[anchorX + 2][anchorY + 4] = true;
		INITIAL_GRID[anchorX + 3][anchorY + 4] = true;
		INITIAL_GRID[anchorX + 4][anchorY + 4] = true;
		INITIAL_GRID[anchorX + 5][anchorY + 4] = true;
	'''
	
	/**
	 * Private helper to set up the Heavyweight SpaceShip (HWSS).
	 */
	private def toLargeSpaceShipSetup(int anchorX, int anchorY) '''
		final int anchorX = «anchorX»;
		final int anchorY = «anchorY»;
		
		INITIAL_GRID[anchorX + 2][anchorY + 0] = true;
		INITIAL_GRID[anchorX + 3][anchorY + 0] = true;
		
		INITIAL_GRID[anchorX + 0][anchorY + 1] = true;
		INITIAL_GRID[anchorX + 5][anchorY + 1] = true;
		
		INITIAL_GRID[anchorX + 6][anchorY + 2] = true;

		INITIAL_GRID[anchorX + 0][anchorY + 3] = true;
		INITIAL_GRID[anchorX + 6][anchorY + 3] = true;
		
		INITIAL_GRID[anchorX + 1][anchorY + 4] = true;
		INITIAL_GRID[anchorX + 2][anchorY + 4] = true;
		INITIAL_GRID[anchorX + 3][anchorY + 4] = true;
		INITIAL_GRID[anchorX + 4][anchorY + 4] = true;
		INITIAL_GRID[anchorX + 5][anchorY + 4] = true;
		INITIAL_GRID[anchorX + 6][anchorY + 4] = true;
	'''
	
	/**
	 * Generates code for the Gosper Glider Gun (36x9) pattern.
	 */
	def toGosperGunSetup(GosperGun gun) '''
		// Pattern GosperGliderGun at («gun.anchor.x», «gun.anchor.y»)
		{
			final int anchorX = «gun.anchor.x»;
			final int anchorY = «gun.anchor.y»;

			// Left Block (2x2)
			INITIAL_GRID[anchorX + 1][anchorY + 4] = true;
			INITIAL_GRID[anchorX + 2][anchorY + 4] = true;
			INITIAL_GRID[anchorX + 1][anchorY + 5] = true;
			INITIAL_GRID[anchorX + 2][anchorY + 5] = true;

			// Left Ship
			INITIAL_GRID[anchorX + 11][anchorY + 4] = true;
			INITIAL_GRID[anchorX + 11][anchorY + 5] = true;
			INITIAL_GRID[anchorX + 11][anchorY + 6] = true;
			INITIAL_GRID[anchorX + 12][anchorY + 3] = true;
			INITIAL_GRID[anchorX + 12][anchorY + 7] = true;
			INITIAL_GRID[anchorX + 13][anchorY + 2] = true;
			INITIAL_GRID[anchorX + 13][anchorY + 8] = true;
			INITIAL_GRID[anchorX + 14][anchorY + 2] = true;
			INITIAL_GRID[anchorX + 14][anchorY + 8] = true;
			INITIAL_GRID[anchorX + 15][anchorY + 5] = true;
			INITIAL_GRID[anchorX + 16][anchorY + 3] = true;
			INITIAL_GRID[anchorX + 16][anchorY + 7] = true;
			INITIAL_GRID[anchorX + 17][anchorY + 4] = true;
			INITIAL_GRID[anchorX + 17][anchorY + 5] = true;
			INITIAL_GRID[anchorX + 17][anchorY + 6] = true;
			INITIAL_GRID[anchorX + 18][anchorY + 5] = true;

			// Right Ship
			INITIAL_GRID[anchorX + 21][anchorY + 2] = true;
			INITIAL_GRID[anchorX + 21][anchorY + 3] = true;
			INITIAL_GRID[anchorX + 21][anchorY + 4] = true;
			INITIAL_GRID[anchorX + 22][anchorY + 2] = true;
			INITIAL_GRID[anchorX + 22][anchorY + 3] = true;
			INITIAL_GRID[anchorX + 22][anchorY + 4] = true;
			INITIAL_GRID[anchorX + 23][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 23][anchorY + 5] = true;
			INITIAL_GRID[anchorX + 25][anchorY + 0] = true;
			INITIAL_GRID[anchorX + 25][anchorY + 1] = true;
			INITIAL_GRID[anchorX + 25][anchorY + 5] = true;
			INITIAL_GRID[anchorX + 25][anchorY + 6] = true;
			
			// Right Block (2x2)
			INITIAL_GRID[anchorX + 35][anchorY + 2] = true;
			INITIAL_GRID[anchorX + 35][anchorY + 3] = true;
			INITIAL_GRID[anchorX + 36][anchorY + 2] = true;
			INITIAL_GRID[anchorX + 36][anchorY + 3] = true;
		}
	'''
	/* =========================================================================================
     * Generates the Java code for defining all reusable patterns in a static Map.
     * This map will store the Live and Dead cell coordinates relative to the pattern's anchor (0,0).
     * =========================================================================================
     */
     def toCustomPatternDefinitions(Model model) '''
        // Helper type stored inside RulesOfLife
        public static final class CustomPatternData {
            public final java.util.List<Point> liveCells;
            public final java.util.List<Point> deadCells;
            public CustomPatternData(java.util.List<Point> liveCells,
                                     java.util.List<Point> deadCells) {
                this.liveCells = liveCells;
                this.deadCells = deadCells;
            }
        }

        public static final java.util.Map<String, CustomPatternData> CUSTOM_PATTERNS
            = new java.util.HashMap<>();

        static {
            «FOR p : model.patterns»
                java.util.List<Point> live_«p.name» = new java.util.ArrayList<>();
                «FOR c : p.cells»
                    live_«p.name».add(new Point(«c.x», «c.y»));
                «ENDFOR»

                java.util.List<Point> dead_«p.name» = new java.util.ArrayList<>();
                «FOR d : p.deadCells»
                    dead_«p.name».add(new Point(«d.x», «d.y»));
                «ENDFOR»

                CUSTOM_PATTERNS.put("«p.name»",
                    new CustomPatternData(live_«p.name», dead_«p.name»));
            «ENDFOR»
        }
    '''
    
    def toApplyPatternMethod() '''
        private static void applyPattern(CustomPatternData data, int ox, int oy) {
            for (Point p : data.liveCells) {
                int x = p.x + ox;
                int y = p.y + oy;
                if (x>=0 && x<GRID_WIDTH && y>=0 && y<GRID_HEIGHT)
                    INITIAL_GRID[x][y] = true;
            }
            for (Point p : data.deadCells) {
                int x = p.x + ox;
                int y = p.y + oy;
                if (x>=0 && x<GRID_WIDTH && y>=0 && y<GRID_HEIGHT)
                    INITIAL_GRID[x][y] = false;
            }
        }
    '''
    def toNamedPatternPlacement(CustPatternState state) '''
	    CustomPatternData patternData_«state.patternRef.name» = CUSTOM_PATTERNS.get("«state.patternRef.name»"); 
		    if (patternData_«state.patternRef.name» != null) {
		        applyPattern(patternData_«state.patternRef.name», «state.offsetX», «state.offsetY»);
		    }
		}
	'''
}