/*
 * generated by Xtext 2.28.0
 */
package goL.tasks.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import goL.tasks.taskDSL.*
import goL.tasks.taskDSL.ParenExpr

/**
 * Generates the RulesOfLife.java file based on the Game of Life DSL model.
 */
class TaskDSLGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		// 1. Get the root Model element
		val model = resource.allContents.filter(Model).head
		
		// 2. Delegate the generation to the dispatch method
		// The generated Java file will be placed in 'src-gen/RulesOfLife.java'
		// It is important that this path reflects the package structure!
		fsa.generateFile("GameOfLife/RulesOfLife.java", model.toJavaCode)
	}

	// Dispatch method for the base type Expr
	def String toJavaCode(Expr expr) {
	    throw new IllegalStateException("Unhandled AST node: " + expr.eClass.name)
	}

	// --- Literal and Variable References ---
	def String toJavaCode(NumberLiteral it) {
	    value.toString
	}
	
	def String toJavaCode(VariableRef it) {
	    varName
	}
	
	def String toJavaCode(ParenExpr it) {
	    '(' + expr.toJavaCode + ')'
	}
	
	// --- Arithmetic Operations ---
	def String toJavaCode(Add it) {
	    '(' + left.toJavaCode + ' + ' + right.toJavaCode + ')'
	}
	
	def String toJavaCode(Sub it) {
	    '(' + left.toJavaCode + ' - ' + right.toJavaCode + ')'
	}
	
	def String toJavaCode(Mul it) {
	    '(' + left.toJavaCode + ' * ' + right.toJavaCode + ')'
	}

	def String toJavaCode(Div it) {
	    '(' + left.toJavaCode + ' / ' + right.toJavaCode + ')'
	}
	
	// Assuming you added {Mod.left=current} to your grammar's MulExpr rule:
	def String toJavaCode(Mod it) {
	    '(' + left.toJavaCode + ' % ' + right.toJavaCode + ')'
	}
	
	// --- Relational and Equality Operations ---
	def String toJavaCode(Eq it) {
	    '(' + left.toJavaCode + ' == ' + right.toJavaCode + ')'
	}
	
	def String toJavaCode(Neq it) {
	    '(' + left.toJavaCode + ' != ' + right.toJavaCode + ')'
	}
	
	def String toJavaCode(Lt it) {
	    '(' + left.toJavaCode + ' < ' + right.toJavaCode + ')'
	}
	
	def String toJavaCode(Lte it) {
	    '(' + left.toJavaCode + ' <= ' + right.toJavaCode + ')'
	}
	
	def String toJavaCode(Gt it) {
	    '(' + left.toJavaCode + ' > ' + right.toJavaCode + ')'
	}
	
	def String toJavaCode(Gte it) {
	    '(' + left.toJavaCode + ' >= ' + right.toJavaCode + ')'
	}
	
	// --- Logical Operations ---
	def String toJavaCode(And it) {
	    '(' + left.toJavaCode + ' && ' + right.toJavaCode + ')'
	}
	
	def String toJavaCode(Or it) {
	    '(' + left.toJavaCode + ' || ' + right.toJavaCode + ')'
	}
	
	// --- Statement Dispatch (Base) ---
	// This is the base dispatch method for statements, similar to the one for Expr.
	def String toJavaCode(Statement statement) {
		throw new IllegalStateException("Unhandled AST node: " + statement.eClass.name)
	}
	
	// --- Statements ---
	def String toJavaCode(VarDecl it) {
	    // Generates: int varName = expr; (Assuming all DSL variables are integers in Java)
	    '''int ''' + it.name + ''' = ''' + it.expr.toJavaCode + ''';'''
	}
	
	def String toJavaCode(Assignment it) {
	    // Generates: varName = expr;
	    it.name + ''' = ''' + it.expr.toJavaCode + ''';'''
	}
	
	def String toJavaCode(IfStatement it) {
	    // Generates: if (condition) { thenStatements... }
	    '''
	        if (''' + it.condition.toJavaCode + ''') {
	            ''' + it.thenStatements.map[toJavaCode].join('''
	            ''') + '''
	        }
	    '''
	    // Since you removed 'else', the optional else block is omitted here.
	}
	
	def String toJavaCode(WhileLoop it) {
	    // Generates: while (condition) { statements... }
	    '''
	        while (''' + it.condition.toJavaCode + ''') {
	            ''' + it.statements.map[toJavaCode].join('''
	            ''') + '''
	        }
	    '''
	}
	
	def String toJavaCode(ReturnStmt it) {
	    // Generates: return expr;
	    '''return ''' + it.expr.toJavaCode + ''';'''
	}
	
	// --- Function Definition ---
	def String toJavaCode(FunctionDef it) {
	    // Generates a public static function (assuming integer return type and parameters for simplicity)
	    val paramStr = it.params.map["int " + it].join(", ")
	    
	    // We assume all user-defined functions are int-returning and public static
	    '''
	        public static int ''' + it.name + '''(''' + paramStr + ''') {
	            ''' + it.statements.map[toJavaCode].join('''
	            ''') + '''
	        }
	    '''
	}
	
	// --- Function Call Fix (for Explicit access) ---
	def String toJavaCode(FunctionCall it) {
	 	// Apply the same 'it.' fix for accessing 'args' if you had the same undefined error there
	    val argStr = it.args.map[toJavaCode].join(', ')
	 	
	 	// Convert built-in functions to Java's Math class, or treat as user-defined
	    switch it.funcName {
	 		case "sin": return "Math.sin(" + argStr + ")"
	 		case "cos": return "Math.cos(" + argStr + ")"
	 		case "tan": return "Math.tan(" + argStr + ")"
	 		case "sqrt": return "Math.sqrt(" + argStr + ")"
	 		case "abs": return "Math.abs(" + argStr + ")"
	 		case "floor": return "Math.floor(" + argStr + ")"
	 		case "ceil": return "Math.ceil(" + argStr + ")"
	 		default: return it.funcName + "(" + argStr + ")"
	 	}
	 }

	
	/**
	 * Main dispatch method that generates the complete Java class.
	 */
	def toJavaCode(Model model) '''
		// This file was automatically generated from the DSL instance: «model.name»
		package GameOfLife; // <-- ADDED PACKAGE DECLARATION
		
		import java.awt.Point;
		import java.util.ArrayList;

		public class RulesOfLife {
		
		    // --- GRID CONFIGURATION (Generated from DSL) ---
		    public static final int GRID_WIDTH = «model.grid.sizeX»;
		    public static final int GRID_HEIGHT = «model.grid.sizeY»;
		
		    // Initial state setup (true = alive)
		    public static boolean[][] INITIAL_GRID = new boolean[GRID_WIDTH][GRID_HEIGHT];
		
		    // Static block to initialize the grid with live cells (defined in the DSL's Grid section)
		    static {
		        «model.grid.toInitialCellSetup»
		    }
		
		
		    // --- EVOLUTION RULES (Generated from DSL) ---
		
		    /**
		     * Determines the next state of a cell based on its current state and live neighbors.
		     * This method contains the custom rules defined in the DSL.
		     * * @param currentState true if the cell is currently alive, false otherwise.
		     * @param liveNeighbors the count of live neighbors (0 to 8).
		     * @return the state of the cell in the next generation.
		     */
		    public static boolean determineNextState(boolean currentState, int liveNeighbors) {
		        
		        // If the cell is currently ALIVE (Survival and Death Rules apply)
		        if (currentState) {
		            // ----------------------------------------------------
		            // SURVIVAL RULES: If any survival rule matches, the cell lives.
		            // ----------------------------------------------------
		            «model.rules.survivalRules.toConditionBlock("Survival")»
		            
		            // ----------------------------------------------------
		            // DEATH RULES: If no survival rule matched, we check for explicit death conditions.
		            // ----------------------------------------------------
		            «model.rules.deathRules.toConditionBlock("Death")»

		            // If a live cell meets neither an explicit survival nor death condition,
		            // it defaults to death (as is standard in most GoL variations).
		            return false;
		            
		        } 
		        
		        // If the cell is currently DEAD (Birth Rules apply)
		        else {
		            // ----------------------------------------------------
		            // BIRTH RULES: If any birth rule matches, the cell is born.
		            // ----------------------------------------------------
		            «model.rules.birthRules.toConditionBlock("Birth")»
		            
		            return false; // Default: stay dead
		        }
		    }
		    
		    // --- GAME LOOP IMPLEMENTATION (Required by GameOfLife.java) ---
		    
		    /**
		     * Computes the list of cells that will be alive in the next generation
		     * based on the current board state and the DSL-defined rules.
		     * * @param gameBoard The current padded board state (true=alive, false=dead).
		     * @param survivingCells The list to which the coordinates of the next generation's live cells will be added.
		     */
		    public static void computeSurvivors(boolean[][] gameBoard, ArrayList<Point> survivingCells) {
		    	// Note: gameBoard is padded by 1 on all sides for neighbor counting (i=1 to length-2)
		        for (int i=1; i<gameBoard.length-1; i++) {
		            for (int j=1; j<gameBoard[0].length-1; j++) {
		                int surrounding = 0;
		                
		                // Neighbor Counting Logic (8 directions)
		                if (gameBoard[i-1][j-1]) { surrounding++; }
		                if (gameBoard[i-1][j])   { surrounding++; }
		                if (gameBoard[i-1][j+1]) { surrounding++; }
		                if (gameBoard[i][j-1])   { surrounding++; }
		                if (gameBoard[i][j+1])   { surrounding++; }
		                if (gameBoard[i+1][j-1]) { surrounding++; }
		                if (gameBoard[i+1][j])   { surrounding++; }
		                if (gameBoard[i+1][j+1]) { surrounding++; }
		                
		                // Determine next state using the DSL-generated rules
		                // The cell at (i, j) corresponds to the unpadded coordinate (i-1, j-1)
		                if (determineNextState(gameBoard[i][j], surrounding)) {
		                    survivingCells.add(new Point(i-1, j-1));
		                }
		            }
		        }
		    }
		}
	'''
	
	
	/**
	 * Generates the Java code for initializing the live cells in the static block.
	 */
	def toInitialCellSetup(Grid grid) '''
		«IF grid.stateOption instanceof RandomState»
			«val randomState = grid.stateOption as RandomState»
			«val percentage = randomState.percentage»
			
			// Use Java's Random to fill the board with the specified percentage (${percentage}%)
			java.util.Random random = new java.util.Random();
			int totalCells = GRID_WIDTH * GRID_HEIGHT;
			int cellsToFill = (int) Math.round(totalCells * (${percentage} / 100.0));
			int filledCount = 0;
	
			// Loop until the desired number of cells is filled
			while (filledCount < cellsToFill) {
				int column = random.nextInt(GRID_WIDTH); // Changed x to column
				int row = random.nextInt(GRID_HEIGHT); // Changed y to row
				
				// Only set if the cell was previously dead
				if (!INITIAL_GRID[column][row]) {
					INITIAL_GRID[column][row] = true;
					filledCount++;
				}
			}
		«ELSEIF grid.stateOption instanceof ProgramState»
			«val progState = grid.stateOption as ProgramState»		
			«val javaCondition = progState.program.toJavaCode» // Capture the generated expression here
			
			// Custom Program Fill: Iterate through every cell (column, row) and evaluate the expression
			for (int row = 0; row < GRID_HEIGHT; row++) {
				for (int column = 0; column < GRID_WIDTH; column++) {
		                // The DSL expression must resolve to a boolean
					if (${javaCondition}) { // <<<--- CORRECT INTERPOLATION FIX
						INITIAL_GRID[column][row] = true;
					}
				}
			}
		«ELSE»
			// Static Fill
			«val staticState = grid.stateOption as StaticState»
			«FOR cell : staticState.cells»
			INITIAL_GRID[${cell.x}][${cell.y}] = true;
			«ENDFOR»
			
		«ENDIF»
	'''
	
	/**
	 * Generates the Java 'if' conditions for the evolution rules.
	 * This helper method takes a list of rules (Birth, Survival, or Death) and generates
	 * the corresponding 'if' blocks, using explicit casting to resolve type dispatch issues.
	 */
	def toConditionBlock(Iterable<?> rules, String ruleType) '''
		«val conditions = switch ruleType {
			case "Birth": rules.filter(BirthRule).map[r | r.toConditionString].join(" || ")
			case "Survival": rules.filter(SurvivalRule).map[r | r.toConditionString].join(" || ")
			case "Death": rules.filter(DeathRule).map[r | r.toConditionString].join(" || ")
			default: ""
		}»
		
		// Generated «ruleType» Condition: «conditions»
		if («conditions») {
			return «IF ruleType == "Birth" || ruleType == "Survival"»true«ELSE»false«ENDIF»;
		}
	'''
	
	/**
	 * Dispatches to the specific rule type to generate the single 'liveNeighbors' condition.
	 */
	def toConditionString(BirthRule rule) {
		'liveNeighbors ' + rule.operator.toSymbol + ' ' + rule.count
	}
	
	def toConditionString(SurvivalRule rule) {
		'liveNeighbors ' + rule.operator.toSymbol + ' ' + rule.count
	}
	
	def toConditionString(DeathRule rule) {
		'liveNeighbors ' + rule.operator.toSymbol + ' ' + rule.count
	}

	/**
	 * Maps the DSL's Operator Enum to the Java Symbol.
	 */
	def toSymbol(Operator operator) {
		switch operator {
			case Operator.LESS_THAN: '<'
			case Operator.EQUAL: '=='
			case Operator.GREATER_THAN: '>'
		}
	}

}