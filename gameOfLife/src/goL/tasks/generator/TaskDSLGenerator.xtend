/*
 * generated by Xtext 2.28.0
 */
package goL.tasks.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import goL.tasks.taskDSL.Model
import goL.tasks.taskDSL.Grid
import goL.tasks.taskDSL.LiveCell
import goL.tasks.taskDSL.Operator
import goL.tasks.taskDSL.BirthRule
import goL.tasks.taskDSL.SurvivalRule
import goL.tasks.taskDSL.DeathRule

/**
 * Generates the RulesOfLife.java file based on the Game of Life DSL model.
 */
class TaskDSLGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		// 1. Get the root Model element
		val model = resource.allContents.filter(Model).head
		
		// 2. Delegate the generation to the dispatch method
		// The generated Java file will be placed in 'src-gen/RulesOfLife.java'
		// It is important that this path reflects the package structure!
		fsa.generateFile("GameOfLife/RulesOfLife.java", model.toJavaCode)
	}
	
	/**
	 * Main dispatch method that generates the complete Java class.
	 */
	def toJavaCode(Model model) '''
		// This file was automatically generated from the DSL instance: «model.name»
		package GameOfLife; // <-- ADDED PACKAGE DECLARATION
		
		import java.awt.Point;
		import java.util.ArrayList;

		public class RulesOfLife {
		
		    // --- GRID CONFIGURATION (Generated from DSL) ---
		    public static final int GRID_WIDTH = «model.grid.sizeX»;
		    public static final int GRID_HEIGHT = «model.grid.sizeY»;
		
		    // Initial state setup (true = alive)
		    public static boolean[][] INITIAL_GRID = new boolean[GRID_WIDTH][GRID_HEIGHT];
		
		    // Static block to initialize the grid with live cells (defined in the DSL's Grid section)
		    static {
		        «model.grid.toInitialCellSetup»
		    }
		
		
		    // --- EVOLUTION RULES (Generated from DSL) ---
		
		    /**
		     * Determines the next state of a cell based on its current state and live neighbors.
		     * This method contains the custom rules defined in the DSL.
		     * * @param currentState true if the cell is currently alive, false otherwise.
		     * @param liveNeighbors the count of live neighbors (0 to 8).
		     * @return the state of the cell in the next generation.
		     */
		    public static boolean determineNextState(boolean currentState, int liveNeighbors) {
		        
		        // If the cell is currently ALIVE (Survival and Death Rules apply)
		        if (currentState) {
		            // ----------------------------------------------------
		            // SURVIVAL RULES: If any survival rule matches, the cell lives.
		            // ----------------------------------------------------
		            «model.rules.survivalRules.toConditionBlock("Survival")»
		            
		            // ----------------------------------------------------
		            // DEATH RULES: If no survival rule matched, we check for explicit death conditions.
		            // ----------------------------------------------------
		            «model.rules.deathRules.toConditionBlock("Death")»

		            // If a live cell meets neither an explicit survival nor death condition,
		            // it defaults to death (as is standard in most GoL variations).
		            return false;
		            
		        } 
		        
		        // If the cell is currently DEAD (Birth Rules apply)
		        else {
		            // ----------------------------------------------------
		            // BIRTH RULES: If any birth rule matches, the cell is born.
		            // ----------------------------------------------------
		            «model.rules.birthRules.toConditionBlock("Birth")»
		            
		            return false; // Default: stay dead
		        }
		    }
		    
		    // --- GAME LOOP IMPLEMENTATION (Required by GameOfLife.java) ---
		    
		    /**
		     * Computes the list of cells that will be alive in the next generation
		     * based on the current board state and the DSL-defined rules.
		     * * @param gameBoard The current padded board state (true=alive, false=dead).
		     * @param survivingCells The list to which the coordinates of the next generation's live cells will be added.
		     */
		    public static void computeSurvivors(boolean[][] gameBoard, ArrayList<Point> survivingCells) {
		    	// Note: gameBoard is padded by 1 on all sides for neighbor counting (i=1 to length-2)
		        for (int i=1; i<gameBoard.length-1; i++) {
		            for (int j=1; j<gameBoard[0].length-1; j++) {
		                int surrounding = 0;
		                
		                // Neighbor Counting Logic (8 directions)
		                if (gameBoard[i-1][j-1]) { surrounding++; }
		                if (gameBoard[i-1][j])   { surrounding++; }
		                if (gameBoard[i-1][j+1]) { surrounding++; }
		                if (gameBoard[i][j-1])   { surrounding++; }
		                if (gameBoard[i][j+1])   { surrounding++; }
		                if (gameBoard[i+1][j-1]) { surrounding++; }
		                if (gameBoard[i+1][j])   { surrounding++; }
		                if (gameBoard[i+1][j+1]) { surrounding++; }
		                
		                // Determine next state using the DSL-generated rules
		                // The cell at (i, j) corresponds to the unpadded coordinate (i-1, j-1)
		                if (determineNextState(gameBoard[i][j], surrounding)) {
		                    survivingCells.add(new Point(i-1, j-1));
		                }
		            }
		        }
		    }
		}
	'''
	
	/**
	 * Generates the Java code for initializing the live cells in the static block.
	 */
	def toInitialCellSetup(Grid grid) '''
		«FOR cell : grid.cells»
		INITIAL_GRID[«cell.x»][«cell.y»] = true;
		«ENDFOR»
	'''
	
	/**
	 * Generates the Java 'if' conditions for the evolution rules.
	 * This helper method takes a list of rules (Birth, Survival, or Death) and generates
	 * the corresponding 'if' blocks, using explicit casting to resolve type dispatch issues.
	 */
	def toConditionBlock(Iterable<?> rules, String ruleType) '''
		«val conditions = switch ruleType {
			case "Birth": rules.filter(BirthRule).map[r | r.toConditionString].join(" || ")
			case "Survival": rules.filter(SurvivalRule).map[r | r.toConditionString].join(" || ")
			case "Death": rules.filter(DeathRule).map[r | r.toConditionString].join(" || ")
			default: ""
		}»
		
		// Generated «ruleType» Condition: «conditions»
		if («conditions») {
			return «IF ruleType == "Birth" || ruleType == "Survival"»true«ELSE»false«ENDIF»;
		}
	'''
	
	/**
	 * Dispatches to the specific rule type to generate the single 'liveNeighbors' condition.
	 */
	def toConditionString(BirthRule rule) {
		'liveNeighbors ' + rule.operator.toSymbol + ' ' + rule.count
	}
	
	def toConditionString(SurvivalRule rule) {
		'liveNeighbors ' + rule.operator.toSymbol + ' ' + rule.count
	}
	
	def toConditionString(DeathRule rule) {
		'liveNeighbors ' + rule.operator.toSymbol + ' ' + rule.count
	}

	/**
	 * Maps the DSL's Operator Enum to the Java Symbol.
	 */
	def toSymbol(Operator operator) {
		switch operator {
			case Operator.LESS_THAN: '<'
			case Operator.EQUAL: '=='
			case Operator.GREATER_THAN: '>'
		}
	}

}